\section{Обзор литературы}

Для разработки программного обеспечения, используются различные \textit{формальные методы}, которые помогают убедиться что система ведёт себя в соответствии с некоторой спецификацией. Одним из таких методов являются \textit{системы типов}. Согласно \cite{book:pierce2002types}, для них можно дать такое определение:


\begin{definition}
Система типов --- это гибко управляемый синтаксический метод доказательства отсутствия в программе определенных видов поведения при помощи классификации выражений языка по разновидностям вычисляемых ими значений.
\end{definition}

Одним из важных свойств этого определения является упор на классификацию термов, согласно значениям, в которые они могут быть вычислены.

В зависимости от типизации, языки программирования можно рассматривать как представителей одной из следующих групп.
\begin{itemize}
\itemsep-1mm
\item Языки с статической типизацией
\item Языки с динамической типизацией
\item Языки с постепенной типизацией
\end{itemize}



Языки со статической типизацией отличает связывание переменных, параметров подпрограмм и возвращаемых значений функций с типом в момент объявления, и этот тип нельзя будем изменить позднее. Таким образом, в момент компиляции мы знаем типы всех выражений. Такое знание позволяет нам проводить некоторые оптимизации и проводить некоторый анализ, на основе которого предоставлять пользователю некоторые подсказки в рамках Интегрированной Среды Разработки (ИСР).

В языках с динамической типизацией, связывание происходит в момент присваивания  значения, во время выполнения программы. Причём одна и та же переменная может быть связана с разными типами, в зависимости от логики программы. Рассмотрим следующий пример.

\vskip4pt
\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\Class{A} {
method1()
}
\Class{B} {
method1()
}

x.method1()
\caption{Пример динамического вызова}
\end{algorithm}
\vskip4pt

%\begin{algorithm}[H]
%\SetAlgoLined
%\DontPrintSemicolon
%\KwData{слово $w={a^{{\delta _1}}}{a^{{\delta _2}}} \ldots {a^{{\delta _k}}}%({\delta _i} \in \{ -1,1\}, k \geqslant 0 )$}
%\KwResult{$G’=(X,V)$ with $V\subseteq U$ such that $G’^{tc}$ is an interval order.}
%\Begin{
%	текущая вершина $\leftarrow$ вершина помеченная символом I\;
%	\For{$i\leftarrow 1$ \KwTo $k$}{
%		\uIf{$\delta_k=1$}{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 	\textit{в направлении, указанном стрелкой} 	
%		}
%		\uElse{
%			текущая вершина $\leftarrow$ вершина в которую можно придти перейдя %из текущей вершины 			в направлении, \textit{противоположном} указанному %стрелкой
%		}
%	}
%}
%\caption{Представление слов как вершин графа циклической группы}
%\end{algorithm}

В зависимости от типа переменной \textit{x}, вызов \textit{x.method1()} может разрешиться в вызов разных методов - из класса A, класса B, или завершиться с ошибкой, если \textit{x} будет другого типа, для которого не определён метод \textit{method1()}. В этом случае мы ограничены в проведении оптимизаций, и ограничены в предоставлении подсказок пользователю в рамках ИСР, потому что в большинстве случаев, до процесса выполнения мы ничего не знаем о типе переменной \textit{x}.

Постепенная типизация представляет собой систему типов, в которой часть переменных и выражений может быть типизированна, и их корректность проверяется в момент компиляции, а часть может быть не типизированна, и об ошибках типизации в них мы узнаем в момент исполнения. При такой типизации мы можем использовать преимущества статической и динамической типизации. Часть кода мы можем типизировать и верифицировать его в момент компиляции. Также компилятор нам может гарантировать некоторый набор оптимизаций, необходимых для ускорения кода. В то же время, в нашем коде мы сможем писать упрощаю