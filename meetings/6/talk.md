### Groovy

Дополнение - они делают вывод типа в @CompileStatic только для локальных переменных.

### Clojure

Ответ: https://groups.google.com/forum/#!topic/clojure/STwhI5t4Z4g

Кратко: используйте теги типа. Как в Java Lite.

### Typed Clojure

http://typedclojure.org/

### Набор правил

#### Неоднозначности

- Несколько реализуемых интерфейсов и класс - выбирается класс как наиболее специфичный тип. Должно работать на автомате из вышеперечисленных правил
- несколько интерфейсов и нет класов.
 - Выбирать случайный - плохо. предсказуемости нету никакой. Такой код плохо дебажится. На машине разработчика может всегда выбираться одно, а у пользователя другое.
 - Выбирать первый, последний, 139 - плохо. В релизе кто-то сделал форматирование кода которое переставило методы - всё сломалось. По сути это тоже самое что прошлый вариант.
 - Кидать исключение - вообще говорят тоже плохо. нельзя взять первый хороший метод, нужно делать проверки что интерфейсов больше нет. Но кажется что этим можно пожертвовать, это наименьшее из зол.


- Примитивные типы 
 - если существует только бокс или анбокс вариант, выбирать его. Если существует оба, то надо определиться какой выбирать. Я считаю что лучший вариант - преедавать боксед версию в Integer. Также это соотносится с тем что делает Groovy.
 
- Варианты с параметрами по умолчанию учитываем. При перегрузке хотелось бы чтобы работал общий алгоритм и dynamic (= Object) выбирался в последнюю очередь (как в Groovy без @CompileStatic).

- если подходят с дефолтными и без них то выбирать с .    если нету другого способа выбрать метод то вызывать его также варарги и дефолтные аргументы


#### Во время компиляции

- Во время компиляции хотелось бы проверять аля C# что есть хотя бы один метод который может удовлетворить перегрузки. Для начала можно предложить такой алгоритм:
  1. Если у нас _dynamic_ передаётся в качестве _i_-го параметра в котором отправитель не является _dynamic_, то в compile-time проверяем что метод с удалённым таким параметром, по правилам __runtime binding__ подходит хотя бы один метод, среди методов нужной арности (с учётом методов с параметрами по умолчанию, varargs) у которых выкинут _i_-ый аргумент. Если их нет, то кидаем Compile Time Binding Exception.
  2. ~~Если отправитель является _dynamic_: (\*)~~
     - ~~Если мы в compile time можем разрешить его тип, то мы действуем согласно пункту 1 (\*)~~
     - Если мы в compile time не можем разрешить его тип, то мы проверяем есть ли вообщем методы которые вызывают подходящие по сигнатуре или нет. Если их нет, то кидаем Compile Time Binding Exception. (\*)
     - 
#### Мысли вслух

- Зависит от реализации, но возможно имеет смысл сохранять найденное в момент CompileTime для более быстрого поиска вариантов в Runtime.

#### Основные правила

1. Составим список методов подходящих по арности. Из них отбираем только те которые можно применить с учётом модификаторов доступа и применимости в зависимости от текущих параметров. Если метод один, то выбираем его. Если методов 0 то кидаем RuntimeBindingException. Иначе идём дальше.
2. Вычисляем метрику расстояния от параметров всех методов из множества до актуальных параметров. Если на одном методе достигается минимальная оценка, то он победил. Если их много то кидаем RuntimeBindingException.

#### Что будет с массивами

```
dynamic s = "fddffd"
Array<dynamic> ad = {s};
Array<String> as = ad
```

Если _dynamic_ расширяется до Object, то всё плохо, а если как первый параметр, то всё хорошо. Можжно ввести значок, например 

```
Array<dynamic!> для первого созданного типа.
```


#### Требование на работу не типизированного кода также как типизированного, упразднено
```
import java.util.*;
import java.lang.*;
import java.io.*;

class Base {}

class Derived extends Base {}

class Runner {
	public  void method(Base b) {
		System.out.println("Base1");
	}
	public  void method(Derived b) {
		System.out.println("Derived1");
	}
}

class Ideone {
	public static void main (String[] args) throws java.lang.Exception {
		Runner r = new Runner();
		Base b = new Derived();
		r.method(b);
	}
}
```


#### ~~Runtime тип у null?

 Пусть у нас есть
 
```
class Base1 { T baseMethod(); }
class Base2 { V baseMethod(); }
Base method(){
    return null;
}

dynamic x = method();
```

Если мы вызываем метод передавая аргументом туда полученный _null_ возможны несколько вариантов:

1. разрешаем как обычный тип считая что null это отец Object.
2. Пробуем локально разрешить тип, как написано ниже. Если смогли то вызываем с ним. ~~Но тогда проблема передачи dynamic->dynamic->dynamic и появляются неоднозначности.~~
Причём для разрешения неоднозначностей понадобится разрешать в несколько этапов. Сначала разрешили типы участников выражений (например функции возвращающие dynamic), а потом всего вместе. Если мы не смогли разрешить то делаем как в пункте 1.

~~Если мы вызываем на этом метод, то всё плоховато.~~

- ```T t = x.baseMethod();``` и ```V v = x.baseMethod();``` впринципе можно разрешить по возвращаемому типу при T != V. 
- как это разрешить непонятно ```x.baseMethod();```. Хотя с точки зрения программиста это вполне рабочий код. Вариант разрешения есть аля Groovy @CompileStatic. Можно пообещать сказав, что если с точки зрения локального скоупа можно разрешить тип, то запоминать его, делая типизированный псевдодинамик.
```
dynamic x = supplier.getBase();
/* some code */
x = supplier.getBase2();
/* some code */
```

оттранслируется в 
``` 
Base x$Base = supplier.getBase();
/* some code */
Base2 x$Base2 = supplier.getBase2();
/* some code */
```
Но при вызове возможно два варианта.  - Вызывать при помощи `x$Base2`,  или присваивать в реальный dynamic  `dynamic x = x$Base2; x.invoke();` Второй вариант кажется более ожидаемым. потому что тогда у нас будет унифицированное поведение везде, и программисту не нужно будет думать - получил ли он переменную в локальном скоупе и компилятор разрешил её тип, или он получил её снаружи. А можно вообще всегда использовать динамик и буть что будет



#### Что делать с extensions?

Они разрешаются статически, а мы станем динамически разрешать.
Идея. Запретим экстеншины.

